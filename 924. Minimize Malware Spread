// uf 原来理解有问题，如果1，2都在一个union，还有个3单独美丽，那返回3， 因为如果1 or 2拿走，1 or 2最终还是会被感染回来。
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int[] parents = new int[graph.length];
        int len = parents.length;
        for (int i = 0; i < len; i++) {
            parents[i] = i;
        }
        for (int i = 0; i < len; i++) {
            for (int j = 0; j < len; j++) {
                if (i != j && graph[i][j] == 1) {
                    int p1 = find(i, parents);
                    int p2 = find(j, parents);
                    if (p1 != p2) {
                        parents[p1] = p2;
                    }
                }
            }
        }
        Map<Integer, Integer> area = new HashMap<>();
        for (int p : parents) {
            int parent = find(p, parents);
            area.put(parent, area.getOrDefault(parent, 0) + 1);
        }
        Arrays.sort(initial);
        int[] vals = new int[graph.length];
        int max = 0;
        int res = 0;
        for (int i = 0; i < initial.length; i++) {
            vals[find(initial[i], parents)]++;
            
        }
        for (int i = 0; i < initial.length; i++) {
            int p = find(initial[i], parents);
            if (vals[p] == 1) {
                int size = area.get(p);
                if (size > max) {
                    max = size;
                    res = i;
                }
            }
        }
        return initial[res];
    }
    private int find(int node, int[] parents){
        if (node != parents[node]) {
            parents[node] = find(parents[node], parents);
        }
        return parents[node];
    }
}


/*  这个也可以 一个意思
private int find(int node, int[] parents){
        int x = node;
        while (x != parents[x]) {
            x = parents[x];
        }
        while (node != x) {
            int p = parents[node];
            parents[node] = x;
            node = p;
        }
        return node;
    }
*/
